* anti-replay TLS à activer ?
* voir ce qu'il faut faire quand le build d'un packet échoue pour les trames,
  peut-être ne les insérer dans le paquet que si correctement buildé (le paquet)
  -> le MUX fait du retry opportuniste, ce serait plutôt à la quic-conn de le faire
  -> voir les URLs des gros fichiers sur haproxy.org pour tester

* voir si le paquet Version Negotiation doit être toujours émis (ou que pour une connection établie)

DDOS -> * drop des paquets 0RTT
 -> voir à activer l'option SSL_OP_NO_ANTI_REPLAY
 si problématique peut être annoncer le non-support de 0RTT avec QUIC

* limiter le boulot pour quic_lstnr_dghdlr() (nombre de dgrams à traiter ?)
réutiliser le max-poll-event ou avoir un settings indépendant

OPTIM * diminuer le nombre de tasklet_wakeup nécessaire au traitement d'un paquet

DDOS -> * Retry : revoir la génération du token
  -> générer une clé random au démarrage, changer la clé toutes les 10s (invalider la clé d'avant ou garder la clé précédente)
  -> concaténér avec l'adresse IP du client + le DCID
  -> avoir une heuristique pour activer la validation du Retry
      probablement un compteur de connexions en cours d'activation (quic-conn avant handshake), possiblement configuré via un settings global

Amélioration diagnostic QUIC
* support pcap + keylogfile
* support QLOG
  -> regarder intérêt du QLOG avec QVIS
* amélioration trace
  -> définir des niveaux de traces
  -> réutiliser la quic_conn pour lockon sur les traces MUX
  -> avoir des traces H3

Tx transport quic-conn
* utiliser sendmsg/sendmmsg pour support envoi datagrammes >16ko
URGENT -> * gérer les cas d'erreur de sendto
  nécessite de gérer l'abonnemement des fds au poller via fd_cant_recv
  abonnement des quic_conn dans des listes par threads attachés aux receivers
  sur réveil de l'IO CB du receiver, lock ou detach de la list head par le
  premier thread réveillé, et wakeup sur l'ensemble des listes
* faire du retry si toutes les trames n'ont pu être envoyées en un seul envoi
  permet de supprimer la boucle opportuniste dans le qc_send du MUX
=> dans un premier temps, enlever les ABORT_NOW() et ajouter une trace stderr
   affichage de la trace limité un compteur (atleast2)


DDOS -> * Initial pkt len check : vérifier quelle soit bien checkée (1200 octets ?)

* la quic-conn peut être conservée le temps de la durée de vie du MUX
  possiblement nettoyer des parties devenus inutile de la quic-conn

* fred a fait grave de la merde
encore une fois
problème d'initialisation des adresses des connexions dans new_quic_cli_conn()
saddr utilisé pour conn->dst -> doit être conn->src
 et flag TO_SET -> FROM_SET
 et il faut récupérer l'adresse destination pour la mettre dans conn->dst
doit fixer l'affichage dans les LOGS des adresses sur haproxy.org via PROXY_PROTOCOL

BUG -> * MUX problème flag CS_EP_EOS
positionné trop tôt, ce qui cause l'échec d'un POST avec HTTP 400 avec abortonclose
ne doit être mis que lorsque un stream est sur le point d'être fermé Rx+Tx

BUG/CRASH -> MUX interrompu en cours de transfer
  0x000055555560ca60 in qcs_free (qcs=0x7ffff0049e90) at src/mux_quic.c:181
  181             BUG_ON(qcs->endp && !(qcs->endp->flags & CS_EP_ORPHAN));
implémenté une logique similaire au mux-h2
envoi d'un GOAWAY ou release si aucun stream ouvert
laisser les streams ouverts se terminés de manière habituelle

STREAM
 -> erreur si réception du meme offset avec des data différentes
   PROTOCOL_VIOLATION
rfc9000 2.2. Sending and Receiving Data
 The data at a given offset MUST NOT change if it is sent
 multiple times; an endpoint MAY treat receipt of different data at
 the same offset within a stream as a connection error of type
 PROTOCOL_VIOLATION.

NCBUF -> static inline pour les fonctions les plus utilisées

DISPATCH DES CONNEXIONS
 * sur réception des premiers paquets Initial avec ODCID, s'assurer qu'on
 redispatch sur un thread valide pour le listener
 * sur allocation des nouveaux CID, assigner le CID sur le thread le moins
 chargé plutôt que le thread courant. Pour éviter de locker sur création CID,
 probablement redispatcher le paquet vers le thread le moins chargé et flagger
 le paquet comme devant donner lieu à création de la quic_conn.

CONNECTION_CLOSE DURING HANDSHAKE
cf RFC 9000 10.2.3.
https://datatracker.ietf.org/doc/html/rfc9000#section-10.2.3
  si envoi nécessaire d'un CONNECTION_CLOSE durant la handshake, il est parfois
  requis de générer la trame dans plusieurs paquets à différents niveau
  d'encryption selon le contexte du client pour garantir qu'il pourra être
  déchiffré. À l'heure actuelle cela n'est pas fait et le CONNECTION_CLOSE est
  envoyé uniquement au niveau actuel de la struct quic_conn

RACE FIN DE HANDSHAKE et INIT MUX ?
vérifier s'il est possible de recevoir des STREAM ou autres trames destinés au
MUX avant son initialisation. Si oui, prévoir de bufferiser ces trames ou
désactiver temporairement la lecture du Rx buf, ou au pire dropper ces trames
en attente de réémission par le client.

MAINTIEN DE LA CONNEXION PAR LA QUIC-CONN
la quic-conn devrait tenter de maintenir la connexion explicitement ouverte
tant que le MUX reste actif. Pour cela il est nécessaire d'émettre des PING si
aucune communication en cours. Cependant il faut rester économe, possiblement
en envoyant un PING que sur expiration proche de l'idle timeout QUIC.

OPTIM -> émission RESET_STREAM par le MUX
chaque stream envoie son RESET_STREAM indépendamment à la couche QUIC-CONN ce
qui cause l'envoi d'un datagramme par RESET_STREAM. À optimiser tout en gardant
la possibilité de savoir si un RESET_STREAM n'a pu être envoyé pour un stream.
