# TODO

Amélioration association FD / CONNECTION
* dans le cas d'un bourrinage de connexions avec Curl, le client se met à réutiliser
  au bout d'un certain temps le même couple IP/PORT
  dans ce cas on va recevoir le traffic pour la nouvelle connexion sur le FD d'une connexion
  obsolète

  pour améliorer cela, il faudrait considérer les FDs des connexions comme des
  accélérateurs pour la connexion active qui peuvent être partagés entre
  plusieurs connexions

  si on reçoit du trafic sur un FD pour une connexion différente que celle
  utilisée pour ce FD, switcher le FD pour qu'il pointe vers cette nouvelle
  connexion

  cela permettrait également de mettre à jour le CID en cas de changement de
  CID par le client sur une même connexion

DDOS ->
  Retry ->  changer la clé toutes les 10s (invalider la clé d'avant ou garder la clé précédente)

OPTIM * diminuer le nombre de tasklet_wakeup nécessaire au traitement d'un paquet
=> MINOR

Amélioration diagnostic QUIC
* support QLOG
  -> regarder intérêt du QLOG avec QVIS
=> MINOR
* amélioration trace
  -> réutiliser la quic_conn pour lockon sur les traces MUX
=> MEDIUM
* logger clés de session TLS dans "show quic"
* compléter dev/flags pour QUIC
* avoir un "show listener" ? permettrait de diagnostiquer la partie quic-sock/quic-receiver-buf
  faire comme "show activity" pour des compteurs par thread ?
=> MEDIUM

Tx transport quic-conn
* utiliser sendmsg/sendmmsg pour support envoi datagrammes >16ko
=> MINOR

* nettoyage quic-conn en état closing/draining
=> MINOR

CONNECTION_CLOSE DURING HANDSHAKE
cf RFC 9000 10.2.3.
https://datatracker.ietf.org/doc/html/rfc9000#section-10.2.3
  si envoi nécessaire d'un CONNECTION_CLOSE durant la handshake, il est parfois
  requis de générer la trame dans plusieurs paquets à différents niveau
  d'encryption selon le contexte du client pour garantir qu'il pourra être
  déchiffré. À l'heure actuelle cela n'est pas fait et le CONNECTION_CLOSE est
  envoyé uniquement au niveau actuel de la struct quic_conn
=> MINOR

MAINTIEN DE LA CONNEXION PAR LA QUIC-CONN
la quic-conn devrait tenter de maintenir la connexion explicitement ouverte
tant que le MUX reste actif. Pour cela il est nécessaire d'émettre des PING si
aucune communication en cours. Cependant il faut rester économe, possiblement
en envoyant un PING que sur expiration proche de l'idle timeout QUIC.
=> MINOR

OPTIM -> émission RESET_STREAM par le MUX
chaque stream envoie son RESET_STREAM indépendamment à la couche QUIC-CONN ce
qui cause l'envoi d'un datagramme par RESET_STREAM. À optimiser tout en gardant
la possibilité de savoir si un RESET_STREAM n'a pu être envoyé pour un stream.
=> MEDIUM

REFACTOR
* utiliser ncbuf pour ACK ranges
  est-ce bien utile ?
* quic_conn_io_cb(): étendre la fonction pour pouvoir gérer plus de 2 encryption levels
  nécessaire notamment pour l'envoi de CONNECTION_CLOSE lors de la handshake
* faire de QPACK un application protocol layer au même niveau que H3
=> MINOR

ARCHI REVIEW
* sur reception CONNECTION_CLOSE
  retourner sur qc_send_mux un code d'erreur
* avant envoi du MUX vérifier taille de window pour ne pas envoyer plus que nécessaire
* éviter de faire du travail pour rien
  dès qu'un datagramme est prêt par qc_prep_app_pkts, l'émettre via qc_send_ppkts
  plutot que générer une liste de datagrammes et tout perdre si erreur sur le premier envoi
* Nouvelle API d'envoi
  -> appel de la quic-conn par le MUX sur chaque stream
  -> remplissage du buffer d'envoi par la quic-conn
  -> envoi du buffer lorsque datagramme rempli
  -> conversation entre chaque envoi
=> MINOR

GESTION DE LA MIGRATION DANS LE CAS DES FD PAR CONNEXION
 Lorsqu'on aura un FD par connexion, le trafic reçu par les FD se répartira
 comme suit:
   - toutefois en cas de migration d'IP et/ou de port, la connexion ne matchera
     plus les paquets et le trafic arrivera à nouveau par le receiver global.
     Il faudra alors être en mesure de flaguer la connexion pour dire qu'elle
     est en cours de migration, de sorte que son I/O handler, dès qu'il aura
     besoin d'émettre, bute la connexion en cours et la recrée vers la nouvelle
     destination (soit avec le même FD soit avec un autre selon ce qui est
     possible). Au moins ça se fera depuis le bon thread et on n'aura pas
     d'autre problème que ça.
 => il faut prévoir qu'il y aura toujours une toute petite part de trafic mal
    aiguillé et donc qu'il faut impérativement qu'on puisse le redispatcher
    en interne comme on le fait déjà.
=> MINOR

RECV DATAGRAM / RXBUF (QUIC_RECEIVER_BUF)
* ne pas faire d'APPEND systématique après usage d'un rxbuf
  plutot faire un INSERT en tête de liste, sauf si taille insuffisante pour
  prochains recv
  -> possiblement dépiler un nouveau rxbuf si multiple datagrammes lus
* remplacer le fake datagram par un champ de la structure rxbuf
  cela économiserait l'allocation d'un quic_dgram
* faire un realign_if_empty, probablement avant de tester l'espace contigue
* aligner les datagrammes buffer sur la ligne de cache
* remplacer l'io-cb par une tasklet
  obligatoire pour supporter le polling en mode edge-triggered
  wakeup de la tasklet si on a atteint le nombre max de dgrams à lire avant de bloquer
  un bon compromis serait de lire maximum 2 datagrammes directement dans l'io-cb
  si 2e datagramme lu, faire un tasklet_wakeup afin de limiter le travail dans l'io-cb
* impossible d'utiliser des fd_stop_recv : dans ce cas, peut etre drop un datagramme
  pour eviter de consommer du CPU. Dans ce cas, peut etre ne le faire qu'à partir
  d'un certain nombre d'échecs successifs pour éviter de dropper trop vite.
=> MEDIUM

* nettoyage des structures avec pa_hole

* implémentation BBR
=> MINOR

* SSL asynchrone
=> MEDIUM: travail d'analyse pour déterminer si l'archi est compatible
=> MINOR

* analyse remontée des erreurs via CONNECTION_CLOSE
* remontée des erreurs H3 via "show error". Et aussi erreurs QUIC ?
  générer une représentation textuelle des trames binaires pour les dumper dans les captures d'erreur
  -> et remplacer le buffer unique par un ring pour dumper plusieurs erreurs
=> MEDIUM

* QUIC coté backend
=> MINOR

* manque d'outillages
  regtest, benchmark, ...
=> MINOR

* isoler le handshake SSL dans une task HEAVY
  pour garantir qu'on ne sature pas un thread avec une handshake SSL
=> MEDIUM

* rajouter log sur erreur handshake
  utiliser send_log + ERR_error_string (cf session_build_err_string)

# Archi limitation

* nettoyage quic_conn_io_cb()

* API émission MUX/quic-conn

* limiter le nombre d'allocations dynamiques
  -> buffer
  -> quic_frame
     sur envoi ne conserver que les paquets chiffrés (à déchiffrer manuellement pour retransmission)

* limiter le nombre de memcpy()
  -> sur réception
  -> sur émission

* gestion des erreurs entre MUX/quic-conn

# Features

* NAT rebinding
* migration de connexion
* ECN
* QUIC coté backend
