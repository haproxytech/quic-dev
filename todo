* anti-replay TLS à activer ?
* voir ce qu'il faut faire quand le build d'un packet échoue pour les trames,
  peut-être ne les insérer dans le paquet que si correctement buildé (le paquet)
  -> le MUX fait du retry opportuniste, ce serait plutôt à la quic-conn de le faire
  -> voir les URLs des gros fichiers sur haproxy.org pour tester

* voir si le paquet Version Negotiation doit être toujours émis (ou que pour une connection établie)

DDOS -> * drop des paquets 0RTT
 -> voir à activer l'option SSL_OP_NO_ANTI_REPLAY
 si problématique peut être annoncer le non-support de 0RTT avec QUIC

* limiter le boulot pour quic_lstnr_dghdlr() (nombre de dgrams à traiter ?)
réutiliser le max-poll-event ou avoir un settings indépendant

OPTIM * diminuer le nombre de tasklet_wakeup nécessaire au traitement d'un paquet

DDOS -> * Retry : revoir la génération du token
  -> générer une clé random au démarrage, changer la clé toutes les 10s (invalider la clé d'avant ou garder la clé précédente)
  -> concaténér avec l'adresse IP du client + le DCID
  -> avoir une heuristique pour activer la validation du Retry
      probablement un compteur de connexions en cours d'activation (quic-conn avant handshake), possiblement configuré via un settings global

Amélioration diagnostic QUIC
* support pcap + keylogfile
* support QLOG
  -> regarder intérêt du QLOG avec QVIS
* amélioration trace
  -> définir des niveaux de traces
  -> réutiliser la quic_conn pour lockon sur les traces MUX
  -> avoir des traces H3

Tx transport quic-conn
* utiliser sendmsg/sendmmsg pour support envoi datagrammes >16ko
URGENT -> * gérer les cas d'erreur de sendto
            utiliser fd_cant_recv sur EAGAIN ou autre cas d'erreur temporaire
* faire du retry si toutes les trames n'ont pu être envoyées en un seul envoi
  permet de supprimer la boucle opportuniste dans le qc_send du MUX
=> dans un premier temps, enlever les ABORT_NOW() et ajouter une trace stderr
   affichage de la trace limité un compteur (atleast2)


DDOS -> * Initial pkt len check : vérifier quelle soit bien checkée (1200 octets ?)

* la quic-conn peut être conservée le temps de la durée de vie du MUX
  possiblement nettoyer des parties devenus inutile de la quic-conn

* fred a fait grave de la merde
encore une fois
problème d'initialisation des adresses des connexions dans new_quic_cli_conn()
saddr utilisé pour conn->dst -> doit être conn->src
 et flag TO_SET -> FROM_SET
 et il faut récupérer l'adresse destination pour la mettre dans conn->dst
doit fixer l'affichage dans les LOGS des adresses sur haproxy.org via PROXY_PROTOCOL

BUG -> * MUX problème flag CS_EP_EOS
positionné trop tôt, ce qui cause l'échec d'un POST avec HTTP 400 avec abortonclose
ne doit être mis que lorsque un stream est sur le point d'être fermé Rx+Tx

BUG/CRASH -> MUX interrompu en cours de transfer
  0x000055555560ca60 in qcs_free (qcs=0x7ffff0049e90) at src/mux_quic.c:181
  181             BUG_ON(qcs->endp && !(qcs->endp->flags & CS_EP_ORPHAN));
implémenté une logique similaire au mux-h2
envoi d'un GOAWAY ou release si aucun stream ouvert
laisser les streams ouverts se terminés de manière habituelle

STREAM
 -> erreur si réception du meme offset avec des data différentes
   PROTOCOL_VIOLATION
rfc9000 2.2. Sending and Receiving Data
 The data at a given offset MUST NOT change if it is sent
 multiple times; an endpoint MAY treat receipt of different data at
 the same offset within a stream as a connection error of type
 PROTOCOL_VIOLATION.

NCBUF -> static inline pour les fonctions les plus utilisées

DISPATCH DES CONNEXIONS
 * sur réception des premiers paquets Initial avec ODCID, s'assurer qu'on
 redispatch sur un thread valide pour le listener
 * sur allocation des nouveaux CID, assigner le CID sur le thread le moins
 chargé plutôt que le thread courant. Pour éviter de locker sur création CID,
 probablement redispatcher le paquet vers le thread le moins chargé et flagger
 le paquet comme devant donner lieu à création de la quic_conn.
