* crypto : ne pas faire de crypto_ctx new + free
* anti-replay TLS a activé ?
* voir ce qu'il faut faire quand le build d'un packet échoue pour les trâmes,
  peut-être ne les insérer dans le paquet que si correctement buildé (le paquet)
* voir si le paquet Version Negotiation doit être toujours émis (ou que pour une connection établie)
* drop des paquets 0RTT

* limiter le boulot pour quic_lstnr_dghdlr() (nombre de dgrams à traiter ?)
* diminuer le nombre de tasklet_wakeup nécessaire au traitement d'un paquet

* pb sur réception d'un CC frame lorsque le mux n'est pas initialisé
  ici :
          case QUIC_FT_CONNECTION_CLOSE:
          case QUIC_FT_CONNECTION_CLOSE_APP:
            /* warn the mux to close the connection */
            qc->qcc->flags |= QC_CF_CC_RECV;
            tasklet_wakeup(qc->qcc->wait_event.tasklet);
            break;

* Retry : revoir la génération du token
  doit contenir des infos pour valider l'adresse client

Amélioration diagnostic QUIC
* support pcap
* support QLOG
  -> regarder intérêt du QLOG avec QVIS
* amélioration trace
  -> définir des niveaux de traces
  -> ajouter des traces dans le MUX
     réutiliser la quic_conn pour lockon sur les traces

Tx transport quic-conn
* utiliser sendmsg/sendmmsg pour support envoi datagrammes >16ko
* gérer les cas d'erreur de sendto
  utiliser fd_cant_recv sur EAGAIN ou autre cas d'erreur temporaire
* faire du retry si toutes les trames n'ont pu être envoyées en un seul envoi
  permet de supprimer la boucle opportuniste dans le qc_send du MUX

Fermeture de connexion
* sur réception CONNECTION_CLOSE libérer le mux et la quic_conn
  à l'heure actuel, les qcs ne sont pas toujours libérer si on n'a pas reçu
  tous les ACKs avant le CONNECTION_CLOSE
  implémenter le draining state en conservant la quic_conn ou juste un état

Acquittement
* actuellement un ACK généré à partir du 2e paquet ack-eliciting reçu
  force le client à réemettre si celui ci n'a qu'un paquet à émettre
  est-ce justifié ?
  de plus nombreuses traces observés "stream not found" avec ngtcp2 à partir d'une dizaine de requêtes
  causé par des retransmissions de ngtcp2. Est-ce que l'envoi des acquittements n'est pas trop retardé coté haproxy ?

  Fred: ce point concerne le fait qu'on ne respecte pas le paramètre de transport
        "max_ack_delay" transmis au peer : on s'engage à émettre des ACKs dans
        un délai imparti.

* Initial pkt len check : vérifier quelle soit bien checkée (1200 octets ?)

* QUIC conn. release avant mux release : ça arrive sur blocage stream, le mux
  n'est pas tué, et xprt idle timeout expire

* problème de PROXY_PROTOCOL : mauvaise adresse IP source reportée
possiblement signe d'éléments manquants au niveau de la connection
