* voir comment purger l'arbre des acks
* crypto : ne pas faire de crypto_ctx new + free
* anti-replay TLS a activé ?
* voir ce qu'il faut faire quand le build d'un packet échoue pour les trâmes,
  peut-être ne les insérer dans le paquet que si correctement buildé (le paquet)
* voir si le paquet Version Negotiation doit être toujours émis (ou que pour une connection établie)
* les clients qui réussissent le plus C1 interop:
  quant kwik aioquic neqo
* voir pb le lag avec curl, sans les patches accept-queue d'Amaury
* drop des paquets 0RTT

* limiter le boulot pour quic_lstnr_dghdlr() (nombre de dgrams à traiter ?)
* diminuer le nombre de tasklet_wakeup nécessaire au traitement d'un paquet

* pb sur réception d'un CC frame lorsque le mux n'est pas initialisé
  ici :
          case QUIC_FT_CONNECTION_CLOSE:
          case QUIC_FT_CONNECTION_CLOSE_APP:
            /* warn the mux to close the connection */
            qc->qcc->flags |= QC_CF_CC_RECV;
            tasklet_wakeup(qc->qcc->wait_event.tasklet);
            break;

* Retry : revoir la génération du token
  doit contenir des infos pour valider l'adresse client

* lorsque le CC est dans l'état recovery vérifier que :
  An endpoint MUST NOT send a packet if it would cause bytes_in_flight (see Appendix B.2)
  to be larger than the congestion window, unless the packet is sent on a PTO timer expiration
  (see Section 6.2) or when entering recovery

Amélioration diagnostic QUIC
* support pcap
* support QLOG
  -> regarder intérêt du QLOG avec QVIS
* amélioration trace
  -> définir des niveaux de traces
  -> ajouter des traces dans le MUX
     réutiliser la quic_conn pour lockon sur les traces

Tx transport quic-conn
* utiliser sendmsg/sendmmsg pour support envoi datagrammes >16ko
* gérer les cas d'erreur de sendto
  utiliser fd_cant_recv sur EAGAIN ou autre cas d'erreur temporaire
* faire du retry si toutes les trames n'ont pu être envoyées en un seul envoi
  permet de supprimer la boucle opportuniste dans le qc_send du MUX

Fermeture de connexion
* sur réception CONNECTION_CLOSE libérer le mux et la quic_conn
  à l'heure actuel, les qcs ne sont pas toujours libérer si on n'a pas reçu
  tous les ACKs avant le CONNECTION_CLOSE
  implémenter le draining state en conservant la quic_conn ou juste un état

Acquittement
* actuellement un ACK généré à partir du 2e paquet ack-eliciting reçu
  force le client à réemettre si celui ci n'a qu'un paquet à émettre
  est-ce justifié ?
  de plus nombreuses traces observés "stream not found" avec ngtcp2 à partir d'une dizaine de requêtes
  causé par des retransmissions de ngtcp2. Est-ce que l'envoi des acquittements n'est pas trop retardé coté haproxy ?
